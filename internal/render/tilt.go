package render

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
	"time"
)

// TiltfileTemplateData contains the data for the Tiltfile template
type TiltfileTemplateData struct {
	Framework      string
	AppName        string
	Port           string
	Date           string
	DevMode        bool
	Services       []interface{}
	IsMultiService bool // Indicates if this is a multi-service project
}

// Base template for multi-service Tiltfile in case the template file doesn't exist
// Commented out as it's currently not used
// const tiltfileTemplateMulti = `# Tiltfile generated by Turbotilt
// # Date: {{.Date}}
//
// k8s_yaml('docker-compose.yml')
// `

const (
	// DefaultTiltfileTemplate is the default template for the Tiltfile
	DefaultTiltfileTemplate = `# Tiltfile generated by Turbotilt (default template)
# Date: [[.Date]]
# Framework: [[.Framework]]
docker_compose('docker-compose.yml')
`

	// DefaultTiltfileMultiTemplate is the default template for the multi-service Tiltfile
	DefaultTiltfileMultiTemplate = `# Multi-service Tiltfile generated by Turbotilt (default template)
# Date: [[.Date]]
docker_compose('docker-compose.yml')
`

	// TemplatePathTiltfile is the path to the Tiltfile template file
	TemplatePathTiltfile = "Tiltfile.tmpl"

	// TemplatePathTiltfileMulti is the path to the multi-service Tiltfile template file
	TemplatePathTiltfileMulti = "Tiltfile.multi.tmpl"
)

// GenerateTiltfile generates a customized Tiltfile for a single-service project
func GenerateTiltfile(opts Options) error {
	// Initialize template service
	ts := NewTemplateService()

	// Prepare data for the template
	appName := "app"
	if opts.AppName == "" {
		// Use current directory name as default name
		cwd, err := os.Getwd()
		if err == nil {
			appName = filepath.Base(cwd)
		}
	} else {
		appName = opts.AppName
	}

	port := DefaultPort // Default port
	if opts.Port != "" {
		port = opts.Port
	}

	// Prepare data to inject into the template
	// Convert services to []interface{} for the template
	services := make([]interface{}, len(opts.Services))
	for i, svc := range opts.Services {
		services[i] = svc
	}

	data := TiltfileTemplateData{
		Framework:      opts.Framework,
		AppName:        appName,
		Port:           port,
		Date:           time.Now().Format("2006-01-02 15:04:05"),
		DevMode:        opts.DevMode,
		Services:       services,
		IsMultiService: false,
	}

	// Default template to use if no template file is found
	const defaultTemplate = `# Tiltfile generated by Turbotilt (default template)
# Date: [[.Date]]
# Framework: [[.Framework]]
docker_compose('docker-compose.yml')
`

	// Try to load the template
	tmpl, err := ts.LoadTemplate("Tiltfile",
		[]string{TemplatePathTiltfile}, defaultTemplate)
	if err != nil {
		return fmt.Errorf("error loading template: %w", err)
	}

	// Generate the Tiltfile
	return ts.RenderToFile("Tiltfile", tmpl, data)
}

// GenerateMultiServiceTiltfile generates a Tiltfile for a multi-service project
func GenerateMultiServiceTiltfile(serviceList ServiceList) error {
	// Initialize template service
	ts := NewTemplateService()

	// Create combined data for all services
	services := make([]map[string]interface{}, len(serviceList.Services))
	for i, svc := range serviceList.Services {
		services[i] = map[string]interface{}{
			"Name":       svc.ServiceName,
			"Path":       svc.Path,
			"Framework":  svc.Framework,
			"Port":       svc.Port,
			"DevMode":    svc.DevMode,
			"JDKVersion": svc.JDKVersion,
		}
	}

	data := TiltfileTemplateData{
		Date:           time.Now().Format("2006-01-02 15:04:05"),
		Services:       []interface{}{services},
		IsMultiService: true,
	}

	// Try to load the template
	tmpl, err := ts.LoadTemplate("Tiltfile",
		[]string{TemplatePathTiltfileMulti, TemplatePathTiltfile},
		DefaultTiltfileMultiTemplate)
	if err != nil {
		return fmt.Errorf("error loading template: %w", err)
	}

	// Generate the Tiltfile
	return ts.RenderToFile("Tiltfile", tmpl, data)
}

// GenerateTiltfileFromTemplate generates a customized Tiltfile for testing
func GenerateTiltfileFromTemplate(opts Options, templatePath string, outputPath string) error {
	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer f.Close()

	// Prepare data for the template
	data := TiltfileTemplateData{
		Framework:      opts.Framework,
		AppName:        opts.AppName,
		Port:           opts.Port,
		Date:           time.Now().Format("2006-01-02 15:04:05"),
		DevMode:        opts.DevMode,
		IsMultiService: false,
	}

	// Load the template from the file
	tmpl, err := template.New(filepath.Base(templatePath)).Delims("[[", "]]").Parse(string(mustReadFile(templatePath)))
	if err != nil {
		return err
	}

	// Execute the template
	return tmpl.Execute(f, data)
}

// mustReadFile reads a file and panics on error
func mustReadFile(path string) []byte {
	data, err := os.ReadFile(path)
	if err != nil {
		panic(err)
	}
	return data
}

// Commented out as it's currently not used
// createTestTemplate creates a template file for testing and returns its path
// func createTestTemplate(content, filename string) (string, error) {
// 	// Create in current directory for tests
// 	err := os.WriteFile(filename, []byte(content), 0644)
// 	if err != nil {
// 		return "", err
// 	}
// 	return filename, nil
// }

// Note: The tiltfileTemplateMulti constant and generateMultiServiceTiltfile function
// have been moved to the top of the file to avoid duplication.
